{"version":3,"sources":["../node_modules/redux-dynamic-modules-react/lib/index.js","../node_modules/@redux-saga/core/dist/redux-saga-effects.esm.js","../node_modules/redux-saga/dist/redux-saga-effects-npm-proxy.esm.js","../node_modules/redux-dynamic-modules-react/lib/DynamicModuleLoader.js","../node_modules/process/browser.js","../../src/common.js","../../src/scope.js","../../src/es5.js","../../src/proxy.js","../../src/patches.js","../../src/immer.js","../../src/index.js"],"names":["__export","m","p","exports","hasOwnProperty","__esModule","require","done","value","qEnd","safeName","patternOrChannel","channel","stringableFunc","String","func","name","fsmIterator","fsm","startState","stateUpdater","errorState","effect","nextState","next","arg","error","currentState","makeIterator","takeEvery","worker","_len","arguments","length","args","Array","_key","action","yTake","take","setAction","ac","q1","q2","fork","apply","concat","takeEvery$1","__extends","this","extendStatics","d","b","Object","setPrototypeOf","__proto__","__","constructor","prototype","create","__assign","assign","t","s","i","n","call","React","react_redux_1","DynamicModuleLoader","_super","render","_this","createElement","ReactReduxContext","Consumer","reactReduxContext","DynamicModuleLoaderImpl","props","Component","_providerInitializationNeeded","_cleanup","_addedModules","remove","undefined","message","console","Error","_store","store","strictMode","state","readyToRender","_addModules","Provider","Fragment","_renderLoader","AddedModulesCleanup","cleanup","children","_a","createStore","modules","addModules","componentDidMount","setState","componentWillUnmount","cachedSetTimeout","cachedClearTimeout","process","module","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","NOTHING","Symbol","DRAFTABLE","DRAFT_STATE","const","proto","isPlainObject","isMap","isSet","overrides","override","key","target","ownKeys","Reflect","obj","base","clone","desc","writable","configurable","iter","thing","x","y","hasSymbol","hasMap","hasSet","self","isEntries","prop","iterator","latest","makeIterable","result","receiver","original","draft","isDraftable","createProxy","wrapSetValue","cloned","isDraft","each","freeze","ImmerScope","isArray","clonePotentialDraft","proxyMap","proxyMethod","proxySet","descriptors","get","assertUnrevoked","peek","prepareCopy","set","is","markChanged","proxyProperty","isEnumerable","scope","parent","modified","finalizing","finalized","assigned","drafts","copy","revoked","enumerable","createHiddenProperty","shallowCopy","usePatches","revoke","leave","mapTraps","finalizeTraps","size","has","delete","clear","forEach","cb","reciever","keys","values","entries","iterateMapValues","iterateSetValues","makeIterateSetValues","setTraps","add","builder","acc","traps","fn","trap","JSON","let","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","baseValue","descriptor","hasChanges","markChangesSweep","object","markChangesRecursively","Proxy","proxy","objectTraps","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","getPrototypeOf","arrayTraps","isNaN","parseInt","reflectTraps","makeTrapsForGetters","assignSet","prev","assignMap","getters","patches","inversePatches","delta","start","end","path","basePath","op","replaceCount","origValue","applyPatches","patch","configDefaults","useProxies","autoFreeze","verifyMinified","onAssign","onDelete","onCopy","Immer","produce","defaultBase","recipe","patchListener","hasError","produceWithPatches","arg1","createDraft","finishDraft","setAutoFreeze","setUseProxies","processResult","baseDraft","isReplaced","finalize","generatePatchesFn","generatePatches","finalizeTree","root","needPatches","finalizeProperty","isDraftProp","isSetMember","rootPath","maybeFreeze","immer"],"mappings":"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","file":"static/js/0.01bcbd9e.chunk.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\n__export(require(\"redux-dynamic-modules-core\"));\n__export(require(\"./DynamicModuleLoader\"));\n","import '@redux-saga/symbols';\nimport '@babel/runtime/helpers/esm/extends';\nimport { channel, stringableFunc, func, notUndef } from '@redux-saga/is';\nimport { q as makeIterator, K as take, L as fork, M as cancel, N as call, O as actionChannel, Q as sliding, U as delay, V as race, c as check } from './io-6de156f3.js';\nexport { O as actionChannel, _ as all, $ as apply, N as call, M as cancel, a4 as cancelled, a0 as cps, U as delay, W as effectTypes, a5 as flush, L as fork, a6 as getContext, a2 as join, Y as put, Z as putResolve, V as race, a3 as select, a7 as setContext, a1 as spawn, K as take, X as takeMaybe } from './io-6de156f3.js';\nimport '@redux-saga/delay-p';\n\nvar done = function done(value) {\n  return {\n    done: true,\n    value: value\n  };\n};\n\nvar qEnd = {};\nfunction safeName(patternOrChannel) {\n  if (channel(patternOrChannel)) {\n    return 'channel';\n  }\n\n  if (stringableFunc(patternOrChannel)) {\n    return String(patternOrChannel);\n  }\n\n  if (func(patternOrChannel)) {\n    return patternOrChannel.name;\n  }\n\n  return String(patternOrChannel);\n}\nfunction fsmIterator(fsm, startState, name) {\n  var stateUpdater,\n      errorState,\n      effect,\n      nextState = startState;\n\n  function next(arg, error) {\n    if (nextState === qEnd) {\n      return done(arg);\n    }\n\n    if (error && !errorState) {\n      nextState = qEnd;\n      throw error;\n    } else {\n      stateUpdater && stateUpdater(arg);\n      var currentState = error ? fsm[errorState](error) : fsm[nextState]();\n      nextState = currentState.nextState;\n      effect = currentState.effect;\n      stateUpdater = currentState.stateUpdater;\n      errorState = currentState.errorState;\n      return nextState === qEnd ? done(arg) : effect;\n    }\n  }\n\n  return makeIterator(next, function (error) {\n    return next(null, error);\n  }, name);\n}\n\nfunction takeEvery(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action,\n      setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action)\n      };\n    }\n  }, 'q1', \"takeEvery(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLatest(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yCancel = function yCancel(task) {\n    return {\n      done: false,\n      value: cancel(task)\n    };\n  };\n\n  var task, action;\n\n  var setTask = function setTask(t) {\n    return task = t;\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return task ? {\n        nextState: 'q3',\n        effect: yCancel(task)\n      } : {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q1',\n        effect: yFork(action),\n        stateUpdater: setTask\n      };\n    }\n  }, 'q1', \"takeLatest(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction takeLeading(patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n\n  var yCall = function yCall(ac) {\n    return {\n      done: false,\n      value: call.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var action;\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q1',\n        effect: yCall(action)\n      };\n    }\n  }, 'q1', \"takeLeading(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nfunction throttle(delayLength, pattern, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, channel;\n  var yActionChannel = {\n    done: false,\n    value: actionChannel(pattern, sliding(1))\n  };\n\n  var yTake = function yTake() {\n    return {\n      done: false,\n      value: take(channel)\n    };\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yDelay = {\n    done: false,\n    value: delay(delayLength)\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setChannel = function setChannel(ch) {\n    return channel = ch;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yActionChannel,\n        stateUpdater: setChannel\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yTake(),\n        stateUpdater: setAction\n      };\n    },\n    q3: function q3() {\n      return {\n        nextState: 'q4',\n        effect: yFork(action)\n      };\n    },\n    q4: function q4() {\n      return {\n        nextState: 'q2',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"throttle(\" + safeName(pattern) + \", \" + worker.name + \")\");\n}\n\nfunction retry(maxTries, delayLength, fn) {\n  var counter = maxTries;\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var yCall = {\n    done: false,\n    value: call.apply(void 0, [fn].concat(args))\n  };\n  var yDelay = {\n    done: false,\n    value: delay(delayLength)\n  };\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yCall,\n        errorState: 'q10'\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: qEnd\n      };\n    },\n    q10: function q10(error) {\n      counter -= 1;\n\n      if (counter <= 0) {\n        throw error;\n      }\n\n      return {\n        nextState: 'q1',\n        effect: yDelay\n      };\n    }\n  }, 'q1', \"retry(\" + fn.name + \")\");\n}\n\nfunction debounceHelper(delayLength, patternOrChannel, worker) {\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var action, raceOutput;\n  var yTake = {\n    done: false,\n    value: take(patternOrChannel)\n  };\n  var yRace = {\n    done: false,\n    value: race({\n      action: take(patternOrChannel),\n      debounce: delay(delayLength)\n    })\n  };\n\n  var yFork = function yFork(ac) {\n    return {\n      done: false,\n      value: fork.apply(void 0, [worker].concat(args, [ac]))\n    };\n  };\n\n  var yNoop = function yNoop(value) {\n    return {\n      done: false,\n      value: value\n    };\n  };\n\n  var setAction = function setAction(ac) {\n    return action = ac;\n  };\n\n  var setRaceOutput = function setRaceOutput(ro) {\n    return raceOutput = ro;\n  };\n\n  return fsmIterator({\n    q1: function q1() {\n      return {\n        nextState: 'q2',\n        effect: yTake,\n        stateUpdater: setAction\n      };\n    },\n    q2: function q2() {\n      return {\n        nextState: 'q3',\n        effect: yRace,\n        stateUpdater: setRaceOutput\n      };\n    },\n    q3: function q3() {\n      return raceOutput.debounce ? {\n        nextState: 'q1',\n        effect: yFork(action)\n      } : {\n        nextState: 'q2',\n        effect: yNoop(raceOutput.action),\n        stateUpdater: setAction\n      };\n    }\n  }, 'q1', \"debounce(\" + safeName(patternOrChannel) + \", \" + worker.name + \")\");\n}\n\nvar validateTakeEffect = function validateTakeEffect(fn, patternOrChannel, worker) {\n  check(patternOrChannel, notUndef, fn.name + \" requires a pattern or channel\");\n  check(worker, notUndef, fn.name + \" requires a saga parameter\");\n};\n\nfunction takeEvery$1(patternOrChannel, worker) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeEvery$1, patternOrChannel, worker);\n  }\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));\n}\nfunction takeLatest$1(patternOrChannel, worker) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeLatest$1, patternOrChannel, worker);\n  }\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));\n}\nfunction takeLeading$1(patternOrChannel, worker) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeLeading$1, patternOrChannel, worker);\n  }\n\n  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    args[_key3 - 2] = arguments[_key3];\n  }\n\n  return fork.apply(void 0, [takeLeading, patternOrChannel, worker].concat(args));\n}\nfunction throttle$1(ms, pattern, worker) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(pattern, notUndef, 'throttle requires a pattern');\n    check(worker, notUndef, 'throttle requires a saga parameter');\n  }\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n    args[_key4 - 3] = arguments[_key4];\n  }\n\n  return fork.apply(void 0, [throttle, ms, pattern, worker].concat(args));\n}\nfunction retry$1(maxTries, delayLength, worker) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n    args[_key5 - 3] = arguments[_key5];\n  }\n\n  return call.apply(void 0, [retry, maxTries, delayLength, worker].concat(args));\n}\nfunction debounce(delayLength, pattern, worker) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {\n    args[_key6 - 3] = arguments[_key6];\n  }\n\n  return fork.apply(void 0, [debounceHelper, delayLength, pattern, worker].concat(args));\n}\n\nexport { debounce, retry$1 as retry, takeEvery$1 as takeEvery, takeLatest$1 as takeLatest, takeLeading$1 as takeLeading, throttle$1 as throttle };\n","export * from '@redux-saga/core/effects';\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nvar React = require(\"react\");\n//@ts-ignore // ReactReduxContext is not officially exported\nvar react_redux_1 = require(\"react-redux\");\n/**\n * The DynamicModuleLoader adds a way to register a module on mount\n * When this component is initialized, the reducer and saga from the module passed as props will be registered with the system\n * On unmount, they will be unregistered\n */\nvar DynamicModuleLoader = /** @class */ (function (_super) {\n    __extends(DynamicModuleLoader, _super);\n    function DynamicModuleLoader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DynamicModuleLoader.prototype.render = function () {\n        var _this = this;\n        return (React.createElement(react_redux_1.ReactReduxContext.Consumer, null, function (reactReduxContext) { return (React.createElement(DynamicModuleLoaderImpl, __assign({}, _this.props, { reactReduxContext: reactReduxContext }))); }));\n    };\n    return DynamicModuleLoader;\n}(React.Component));\nexports.DynamicModuleLoader = DynamicModuleLoader;\nvar DynamicModuleLoaderImpl = /** @class */ (function (_super) {\n    __extends(DynamicModuleLoaderImpl, _super);\n    function DynamicModuleLoaderImpl(props) {\n        var _this = _super.call(this, props) || this;\n        /** Flag that indicates we need to create a store/provider because a parent store was not provided */\n        _this._providerInitializationNeeded = false;\n        /**\n         * Unregister sagas and reducers\n         */\n        _this._cleanup = function () {\n            if (_this._addedModules) {\n                _this._addedModules.remove();\n                _this._addedModules = undefined;\n            }\n        };\n        if (props.reactReduxContext == null) {\n            var message = \"Tried to render DynamicModuleLoader, but no ReactReduxContext was provided\";\n            console.error(message);\n            throw new Error(message);\n        }\n        _this._store = props.reactReduxContext\n            ? props.reactReduxContext.store\n            : undefined;\n        // We are not in strict mode, let's add the modules ASAP\n        if (!_this.props.strictMode) {\n            _this._addModules();\n            _this.state = { readyToRender: true };\n        }\n        else {\n            // We are in strict mode, so have to wait for CDM to add modules.\n            // Thus, we cannot render the children at this time\n            _this.state = { readyToRender: false };\n        }\n        return _this;\n    }\n    DynamicModuleLoaderImpl.prototype.render = function () {\n        if (this.state.readyToRender) {\n            if (this._providerInitializationNeeded) {\n                return (React.createElement(react_redux_1.Provider, { store: this._store },\n                    React.createElement(DynamicModuleLoader, __assign({}, this.props))));\n            }\n            return (React.createElement(React.Fragment, null,\n                this._renderLoader(),\n                React.createElement(AddedModulesCleanup, { cleanup: this._cleanup })));\n        }\n        return null;\n    };\n    /**\n     * Render a Redux provider\n     */\n    DynamicModuleLoaderImpl.prototype._renderLoader = function () {\n        return this.props.children\n            ? typeof this.props.children === \"function\"\n                ? this.props.children()\n                : this.props.children\n            : null;\n    };\n    DynamicModuleLoaderImpl.prototype._addModules = function () {\n        var _a = this.props, createStore = _a.createStore, modules = _a.modules;\n        if (!this._store) {\n            // If we need to create a store, do that here. We will skip adding the modules and render DML again\n            if (createStore) {\n                this._store = createStore();\n                this._providerInitializationNeeded = true;\n            }\n            else {\n                throw new Error(\"Store could not be resolved from React context\");\n            }\n        }\n        else {\n            // Add the modules here\n            this._addedModules = this._store.addModules(modules);\n        }\n    };\n    DynamicModuleLoaderImpl.prototype.componentDidMount = function () {\n        if (this.props.strictMode) {\n            this._addModules();\n            this.setState({ readyToRender: true });\n        }\n    };\n    return DynamicModuleLoaderImpl;\n}(React.Component));\n/**\n * This component is rendered as the last child of DynamicModuleLoaderImpl\n * so react runs willUnmount on connected(react-redux) children before this\n * cleanup and allows them to unsubscribe from store before dynamic reducers\n * removing (and avoid errors in selectors)\n */\nvar AddedModulesCleanup = /** @class */ (function (_super) {\n    __extends(AddedModulesCleanup, _super);\n    function AddedModulesCleanup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AddedModulesCleanup.prototype.render = function () {\n        return null;\n    };\n    AddedModulesCleanup.prototype.componentWillUnmount = function () {\n        this.props.cleanup();\n    };\n    return AddedModulesCleanup;\n}(React.Component));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) { target.delete(prev); }\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) { return target.set(key, value); });\n  return target;\n}\nvar assign = Object.assign || (function (target) {\n  var overrides = [], len = arguments.length - 1;\n  while ( len-- > 0 ) overrides[ len ] = arguments[ len + 1 ];\n\n  overrides.forEach(function (override) { return Object.keys(override).forEach(function (key) { return target[key] = override[key]; }); });\n  return target;\n});\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  if (isMap(base)) { return new Map(base); }\n  if (isSet(base)) { return new Set(base); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) { return iter(index, entry, obj); });\n  } else {\n    ownKeys(obj).forEach(function (key) { return iter(key, obj[key], obj); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var obj;\n\n  var self;\n  return self = ( obj = {}, obj[Symbol.iterator] = function () { return self; }, obj.next = next, obj );\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  if (isMap(obj)) { return new Map(obj); }\n  if (isSet(obj)) { return new Set(obj); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if ( deep === void 0 ) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) { return freeze(value, true); }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) { return latest$1(state).size; },\n  has: function (state) { return function (key) { return latest$1(state).has(key); }; },\n  set: function (state) { return function (key, value) {\n    if (latest$1(state).get(key) !== value) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (key) {\n    prepareCopy(state);\n    markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return false;\n  }; },\n  clear: function (state) { return function () {\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    markChanged(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; },\n  forEach: function (state, key, reciever) { return function (cb) {\n    latest$1(state).forEach(function (value, key, map) {\n      cb(reciever.get(key), key, map);\n    });\n  }; },\n  get: function (state) { return function (key) {\n    var value = latest$1(state).get(key);\n\n    if (state.finalizing || state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value;\n    }\n\n    var draft = createProxy(value, state);\n    prepareCopy(state);\n    state.copy.set(key, draft);\n    return draft;\n  }; },\n  keys: function (state) { return function () { return latest$1(state).keys(); }; },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) { return function (value) {\n    if (!latest$1(state).has(value)) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (value) {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.delete(value);\n  }; },\n  has: function (state) { return function (key) {\n    return latest$1(state).has(key);\n  }; },\n  clear: function (state) { return function () {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.clear();\n  }; },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) { markChanged(state); }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters(( obj$1 = {}, obj$1[DRAFT_STATE] = function (state) { return state; }, obj$1.size = function (state) { return latest$2(state).size; }, obj$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1.set = function (state) { return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; }, obj$1.delete = function (state) { return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  }; }, obj$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; }, obj$1.forEach = function (state, _, receiver) { return function (cb, thisArg) { return latest$2(state).forEach(function (_, key, map) {\n    var value = receiver.get(key);\n    cb.call(thisArg, value, key, map);\n  }); }; }, obj$1.get = function (state) { return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  }; }, obj$1.keys = function (state) { return function () { return latest$2(state).keys(); }; }, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1 ));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters(( obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) { return state; }, obj$1$1.size = function (state) { return latest$2(state).size; }, obj$1$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1$1.add = function (state) { return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; }, obj$1$1.delete = function (state) { return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  }; }, obj$1$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  }; }, obj$1$1.forEach = function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1 ));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) { assignMap(copy, drafts); }else { assign(copy, drafts); }\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [], len = arguments.length - 1;\n      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return Reflect[name].apply(Reflect, [ latest$2(state) ].concat( args ));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) { this$1.onDelete(state, prop); }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n",null,null,null,null,null,null],"sourceRoot":""}